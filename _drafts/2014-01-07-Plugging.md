---
layout: deafult
title: Plugging
---

## Plugins with node

When working with node applications I've often needed a plugin architecture, whether it be
with personal projects, the [Adapt framework](https://community.adaptlearning.org) or more recently
[jsbin](http://jsbin.com). One thing that has been tricky is actually working out how to
implement plugins. 

After different attempts and a bit of an epithany when integrating [Stripe](http://stripe.com)
into jsbin, I came up with [Plugging](http://npmjs.org/package/plugging)! After a few iterations
and a genuine use case I settled on an API that is small and generic.

To install to your project just run
{% highlight bash %}
    npm install plugging
{% endhighlight %}

Plugins can take two forms, either an an object with a predefined 'init' method or a function.
Below I'll write the same plugin in both forms.

### Plugin as a function

{% highlight javascript %}
    /**
     *  /Users/allouis/dev/project/plugins/myPlugin/index.js
     */
    
    var APIRouteHandler = require('./lib/handlers/api'),
        APIAuth         = require('./lib/handlers/auth'),
        APIParamParser  = require('./lib/params/api');

    module.exports = function(options) {
        var app = options.app,
            APISecurityEnabled = options.API;

        if (APISecurityEnabled) { // Plugins should take care of their own loading logic;
            app.param('apiKey', APIParamParser);
            app.get(/api/:apiKey, APIRouteHandler); 
        }

    }

{% endhighlight %}

### Plugin as an object

{% highlight javascript %}
    /**
     *  /Users/allouis/dev/project/plugins/myPlugin.js
     *  You can define your plugins as both files and folder
     */

    var APIRouteHandler = require('./lib/handlers/api'),
        APIAuth         = require('./lib/handlers/auth'),
        APIParamParser  = require('./lib/params/api'),
        APISecurityEnabled;

    exports.init = function(options) {

        var app = options.app;
        APISecurityEnabled = options.API;

        if (APISecurityEnabled) { // Plugins should take care of their own loading logic;
            app.param('apiKey', APIParamParser);
            app.get(/api/:apiKey, APIRouteHandler); 
        }

    }

    exports.checkAPIKey = function(key) {
        if (!APISecurityEnabled) {
            return false;
        }
        return APIParamParser(key);
    }
    
{% endhighlight %}

I would use plugins as functions for more self contained, somewhat remote, plugins,
wheras the object style, for plugins that require an initialisation or setup, but then 
provide an accessible API that can be required within the project, however I would say
that a plugin that provides an API is not a plugin in the sense that it can be altogether
removed, which is why the `checkAPIKey` method above has a fallback response if the plugin 
is not active.

Plugins are loaded via the inital call to the plugging library, and can either be executed
immediately or later in the app

### Deffered plugin loading

{% highlight javascript %}
    var http        = require('http'),
        express     = require('express'),
        options     = require('./config'),
        plugging    = require('plugging')(__dirname + '/plugins');
        // Pass in the path to your plugins directory
    
    var app = express();

    app.configure(function(){
        //...
    })

    var server = http.createServer(app);

    server.listen(app.get('port'));

    pluggings.start({
        app: app,
        API: options.API
    }) // this initializes the plugins passing all parameters to the plugin

{% endhighlight %}

### Immediate plugin loading

{% highlight javascript %}
    var http        = require('http'),
        express     = require('express'),
        options     = require('./config');
    
    var app = express();

    app.configure(function(){
        //...
    })

    var server = http.createServer(app);

    server.listen(app.get('port'));

    var pluginOptions = {
        app: app,
        API: app.get('port') === options.APIPort ? true : false
    }

    // If pluggings is passed more than one argument it initialises 
    // plugins immediately passing all extra parameters to plugins
    require('pluggings')(__dirname + '/plugins', pluginOptions);

{% endhighlight %}

The most common use case would to be passing in environment variables or config options,
this allows your plugins to 'setup' and work out if they are even needed, and then be started
once you're connected to your database store and app is being configured / listening on ports 
!!TODO!!

You can configure how plugging works on a basic level, and I'm open to added more config options
as and when required/request, as of this blog post there are two config options, defaults shown 
below

{% highlight javascript %}
    {
        "node_modules": false,
        "init":"init"
    }

{% endhighlight %}

Those are the default configs, setting `node_modules` to true well tell plugging to scan the top 
level of your node_modules and look for anythign with a `"plugging: true"` in the package.json
and use that as a plugin. the `init` key is the name of the method that gets called on object 
style plugins when they're started.

